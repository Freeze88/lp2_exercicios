## Problema

29 - O ficheiro [`029.tsv`](02/029.tsv) contém dados, separados por _tabs_,
sobre todos os exoplanetas conhecidos (a 30-11-2018). Cada linha contém a
seguinte informação:

* ID do planeta
* Nome do sistema estelar a que o planeta pertence
* Letra do planeta dentro do seu sistema estelar
* Nome do planeta
* Método de deteção do planeta
* Período orbital em dias
* Distância em _parsecs_
* Temperatura em Kelvins
* Telescópio responsável pela descoberta

As linhas que começam com o carácter `#` são comentários e devem ser ignoradas.

Cria um projeto no Visual Studio que respeite os seguintes requisitos:

1. Enumeração que contenha os diferentes métodos de descoberta de exoplanetas.
2. _Struct_ imutável `Planet`, que contém toda a informação sobre um planeta
   sob a forma de propriedades só de leitura e um construtor para inicializar
   essas mesmas propriedades. Cada propriedade deve ser do tipo apropriado ao
   dado que reporta.
3. A _struct_ `Planet` deve ter _overrides_ de `GetHashCode()` e `Equals()` de
   modo a que a igualdade entre planetas dependa apenas do respetivo ID.
4. Classe `PlanetLoader`, com um único método `LoadPlanets()`. Este método
   aceita um parâmetro o nome de ficheiro que contém os dados sobre os
   planetas, devolvendo um `IEnumerable<Planet>` com todos os planetas lidos.
   Tanto a classe como o método devem ser `static`.
5. Classe `Program`, com método `Main()`, no qual é invocado o método
   `LoadPlanets()`, e posteriormente mostrada no ecrã a seguinte informação,
   obtida com o uso de Lambdas e LINQ (sintaxe fluente ou expressões _query_,
   sem preferência):
   * Número de exoplanetas existentes.
   * Método mais comum de deteção.
   * Máximo de exoplanetas em torno da mesma estrela.
   * Média do período orbital.
   * Planeta mais longínquo (e a respetiva distância).
   * Média da temperatura dos planetas cuja estrela tem pelo menos dois
     planetas.
   * Telescópio com menos descobertas.
6. Todas as possíveis exceções devem ser tratadas ao nível da classe
   `Program`.
7. Todas as classes e respetivos membros devem estar documentados com
   comentários XML.

> [Soluções](../solucoes/02/029.md)

## Soluções

### Solução 1

```cs
namespace Exercises
{
    /// <summary>
    /// Struct responsible for storing the information about a planet
    /// </summary>
    public struct Planet
    {
        // Planet ID
        public int id { get; }
        // Name of the Star it orbits
        public string hostname { get; }
        // Letter of the planet
        public char letter { get; }
        // Name of the planet
        public string name { get; }
        // Enum containing the discovery method
        public Discovery discmethod { get; }
        // Orbital period (in days)
        public float orbitperiod { get; }
        // Distance of the planet (in parsecs)
        public float distance { get; }
        // Temperature of the planet (in Kelvin)
        public float temp { get; }
        // Facility where it was discovered
        public string facility { get; }

        /// <summary>
        /// Constructor of the struct initializing all properties with the
        /// values given on PlanetLoader
        /// </summary>
        /// <param name="id"></param>
        /// <param name="hostname"></param>
        /// <param name="letter"></param>
        /// <param name="name"></param>
        /// <param name="discmethod"></param>
        /// <param name="orbitperiod"></param>
        /// <param name="distance"></param>
        /// <param name="temp"></param>
        /// <param name="facility"></param>
        public Planet(int id, string hostname, char letter, string name, Discovery discmethod,
            float orbitperiod, float distance, float temp, string facility)
        {
            this.id = id;
            this.hostname = hostname;
            this.letter = letter;
            this.name = name;
            this.discmethod = discmethod;
            this.orbitperiod = orbitperiod;
            this.distance = distance;
            this.temp = temp;
            this.facility = facility;
        }

        // Override of GetHashCode() to return the planet ID instead
        public override int GetHashCode()
        {
            return id;
        }

        // Override of Equals() comparing the IDs
        public override bool Equals(object obj)
        {
            Planet? c = obj as Planet?;
            return c?.id == this.id;
        }
    }
}
```

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Exercises
{
    /// <summary>
    /// Responsible for showing information about the planets
    /// </summary>
    class Program
    {
        /// <summary>
        /// Searches a IEnumerable of planets using Linq and displays the
        /// information obtained
        /// </summary>
        /// <param name="args"></param>
        private static void Main(string[] args)
        {
            // Initializes planetloader sending it the file name saving what it
            // returns to a IEnumerable of Planet
            IEnumerable<Planet> planetsListing = PlanetLoader.LoadPlanets("029.tsv");

            // Searches the list of planets for the most common discovery method
            Discovery commonDiscMethod = 
                planetsListing.GroupBy(c => c.discmethod)
                .OrderByDescending(c => c.Count())
                .First().Key;

            // Searches the list of planets for the maximum amount of planets
            //orbiting the same star
            IEnumerable<Planet> maxPlanetsOnSameStar = 
                planetsListing.GroupBy(c => c.hostname)
                .OrderByDescending(c => c.Count())
                .First();

            // Gets the average orbital period of all the planets
            double averageOrbitalPeriod = 
                planetsListing.Average(c => c.orbitperiod);

            // Searches the list of planets for the most distant one
            Planet mostDistantPlanet =
                planetsListing.Where(s => s.distance == planetsListing
                .Max(s => s.distance))
                .First();

            // Orders the list by amount of discoveries and returns the first
            string lessDiscoveries = 
                planetsListing.GroupBy(c => c.facility)
                .OrderByDescending(c => c.Count())
                .Last().Key;

            // Searches the list for planets where the hostname appears more
            // than once and avarages their temperature
            float avarageTemp = planetsListing.GroupBy(c => c.hostname)
                .Where(v => v.Count() > 1)
                .SelectMany(n => n)
                .Average(k => k.temp);

            // Block to display the information to the user
            Console.WriteLine($"Number of exo-planets : {planetsListing.Count()}");

            Console.WriteLine("");

            Console.WriteLine($"Most common discovery method : {commonDiscMethod}");

            Console.WriteLine("");

            Console.WriteLine($"Maximum amount of planets around the same " +
                $"star : {maxPlanetsOnSameStar.Count()}");

            Console.WriteLine("");

            Console.WriteLine($"Average orbital period of all the planets " +
                $": {averageOrbitalPeriod} days");

            Console.WriteLine("");

            Console.WriteLine($"Most distant planet : {mostDistantPlanet.name}" +
                $" ({mostDistantPlanet.distance} parsecs)");

            Console.WriteLine("");

            Console.WriteLine($"Average temperature of the planets whose" +
                $" host has 2 or more planets : {avarageTemp} k");

            Console.WriteLine("");

            Console.WriteLine($"Facility with less discoveries :" +
                $" {lessDiscoveries}");
        }
    }

    /// <summary>
    /// Enum containing all possible discovery methods
    /// </summary>
    public enum Discovery
    {
        radialvelocity,
        imaging,
        transit,
        orbitalbrightnessmodulation,
        eclipsetimingvariations,
        pulsationtimingvariations,
        microlensing,
        pulsartiming,
        transittimingvariations,
        astrometry
    }
}
```

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Exercises
{
    /// <summary>
    /// Responsible for parsing the document given
    /// </summary>
    static class PlanetLoader
    {
        /// <summary>
        /// Parses the document and creates a Planet with the contents of each
        /// line
        /// </summary>
        /// <param name="fileName"> Name of the file to parse </param>
        /// <returns> IEnumerable of all the planets </returns>
        public static IEnumerable<Planet> LoadPlanets(string fileName)
        {
            // String storing the path to the file being acessed
            string filePath = Path.Combine(Environment.GetFolderPath
                (Environment.SpecialFolder.Desktop), fileName);

            // File Streamer set to read
            FileStream fileStreamer =
                new FileStream(filePath, FileMode.Open, FileAccess.Read);

            // New stream reader receiving the file streamer created
            StreamReader reader = new StreamReader(fileStreamer);

            // Initializes a list<> of planets
            List<Planet> planets = new List<Planet>();

            // Performs the loop while the 'reader' has not reached the end
            while (!reader.EndOfStream)
            {
                // Creates a string and assigns it the next line in the file
                string fileLine = reader.ReadLine();

                // Only enters in case it's not a comment or a description
                if (fileLine?[0] != '#' && fileLine?[0] != 'l')
                {
                    // Splits the string on 'fileLine' by the tabs and stores
                    // it on a array of strings
                    string[] splittedLine = fileLine.Split('\t');

                    // Formats the fourth string to be able to be parsed into
                    // 'Descovery'
                    // --Note-- Names on 'Discovery' are the same as the file
                    // but lower case and without spaces
                    string toParseDiscovery = new string(splittedLine[4]
                        .ToLower().Where(c => !char.IsWhiteSpace(c)).ToArray());

                    // Try Parses the strings on 'splittedLine' by order,
                    // Creating and assigning the variables needed
                    Int32.TryParse(splittedLine[0], out int id);

                    string hostname = splittedLine[1];

                    char letter = splittedLine[2][0];

                    string name = splittedLine[3];

                    Enum.TryParse(toParseDiscovery, out Discovery discmethod);

                    Single.TryParse(splittedLine[5].Replace('.', ','), out float orbitperiod);

                    Single.TryParse(splittedLine[6].Replace('.', ','), out float distance);

                    Single.TryParse(splittedLine[7].Replace('.', ','), out float temp);

                    string facility = splittedLine[8];

                    // Creates a new planet with the parsed variables and
                    // Adds it to the list
                    planets.Add(new Planet(id, hostname, letter, name, discmethod, orbitperiod, distance, temp, facility));
                }
            }
            // Closes the stream reader
            reader.Close();

            // Creates a IEnumerable of planets and equals it to the list planets
            IEnumerable<Planet> toReturn = planets;

            // Returns the IEnumerable 'toReturn'
            return toReturn;
        }
    }
}
```

*Por [André Vitorino](https://github.com/Freeze88).*